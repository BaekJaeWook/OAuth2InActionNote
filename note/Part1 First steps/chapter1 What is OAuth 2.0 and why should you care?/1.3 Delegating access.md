**OAuth is a protocol designed to do exactly that**: **in OAuth, :key:*the end user delegates some part of their authority to access the protected resource to the client application to act on their behalf***:key:. ***To make that happen*, OAuth introduces *another component* into the system: *the authorization server* (figure 1.7:framed_picture:)**.

***:key:The authorization server (AS) is trusted by the protected resource to issue special-purpose security credentials—called OAuth access tokens—to clients***. *To acquire a token, the client first sends the resource owner to the authorization server in order to request that the resource owner authorize this client. The resource owner authenticates to the authorization server and is generally presented with a choice of whether to authorize the client making the request. The client is able to ask for a subset of functionality, or scopes, which the resource owner may be able to further [diminish](https://dictionary.cambridge.org/us/dictionary/english/diminish). Once the authorization grant has been made, the client can then request an access token from the authorization server. This access token can be used at the protected resource to access the API, as granted by the resource owner (see figure 1.8:framed_picture:):key:*.

***At no time in this process are the resource owner’s credentials exposed to the client***: the resource owner authenticates to the authorization server separately from anything used to communicate with the client. **Neither does the client have a high-powered developer key**: the client is unable to access anything on its own and instead must be authorized by a valid resource owner before it can access any protected resources. This is true even though most OAuth clients have a means of authenticating themselves to
the authorization server.

**The user generally never has to see or deal with the access token directly**. Instead of requiring the user to generate tokens and paste them into clients, the OAuth protocol [facilitates](https://dictionary.cambridge.org/us/dictionary/english/facilitate) this process and makes it relatively simple for the client to request a token and the user to authorize the client. Clients can then manage the tokens, and users can manage the client applications.

**This is a general overview of how the OAuth protocol works, but in fact there are several ways to get an access token using OAuth**. We’ll discuss the details of this process in chapter 2 by looking in more detail at the authorization code grant type of OAuth 2.0. We’ll cover other methods of getting access tokens in chapter 6.

### ~~Beyond HTTP Basic and the password-sharing antipattern~~

Many of the more “traditional” approaches listed in the previous section are examples of the **password antipattern**, in which **a shared secret (the password) directly represents the party in question (the user)**. By sharing this secret password with applications, the user enables applications to access protected APIs. However, as we’ve shown, this is [fraught](https://dictionary.cambridge.org/us/dictionary/english/fraught) with real-world problems. Passwords can be stolen or guessed, a password from one service is likely to be used verbatim on another service by the same user, and storage of passwords for future API access makes them even more susceptible to theft.

**How did HTTP APIs become password-protected in the first place?** The history of the HTTP protocol and its security methods is [enlightening](https://dictionary.cambridge.org/us/dictionary/english/enlightening). **The HTTP protocol defines a mechanism whereby a user in a browser is able to authenticate to a web page using a username and password over a protocol known as *HTTP Basic Auth***. There is also a slightly more secure version of this, known as HTTP Digest Auth, but for our purposes they are interchangeable as both assume the presence of a user and effectively require the presentation of a username and password to the HTTP server. Additionally, because HTTP is a stateless protocol, it’s assumed that these credentials will be presented again on every single transaction.

**This all makes sense in light of HTTP’s origins as a document access protocol**, but the web has grown significantly in both scope and [breadth](https://dictionary.cambridge.org/us/dictionary/english/breadth) of use since those early days. **HTTP as a protocol makes no distinction between transactions with a browser in which the user is present and transactions with another piece of software without an intermediary browser**. This fundamental flexibility has been key to the [unfathomable](https://dictionary.cambridge.org/us/dictionary/english/unfathomable) success and adoption of the HTTP protocol. **But as a consequence, when HTTP started to be used for direct-access APIs in addition to user-facing services, its existing security mechanisms were quickly adopted for this new use case**. **This simple technological decision has contributed to the long-running misuse of continuously-presented passwords for both APIs and user-facing pages**. Whereas browsers have cookies and other session-management techniques at their [disposal](https://dictionary.cambridge.org/us/dictionary/english/disposal), the types of HTTP clients that generally access a web API do not.

**OAuth was designed from the [outset](https://dictionary.cambridge.org/us/dictionary/english/outset) as a protocol for use with APIs, [wherein](https://dictionary.cambridge.org/us/dictionary/english/wherein) the main interaction is outside of the browser**. It usually has an end user in a browser to start the process, and indeed this is where the flexibility and power in the delegation model comes from, but the final steps of receiving the token and using it at a protected resource lie outside the view of the user. In fact, some of the key use cases of OAuth occur when the user is no longer present at the client, yet the client is still able to act on the user’s behalf. Using OAuth allows us to move past the notions and assumptions of the HTTP Basic protocol in a way that’s powerful, secure, and designed to work with today’s API-based economy.

---

### Authorization delegation: why it matters and how it’s used

***Fundamental to the power of OAuth is the notion of :key:delegation:key:***. Although OAuth is often called an authorization protocol (and this is the name given to it in the RFC which defines it), it is a delegation protocol. Generally, a subset of a user’s authorization is delegated, but OAuth itself doesn’t carry or convey the authorizations. Instead, it provides a means by which *a client can request that a user delegate some of their authority to it. The user can then approve this request, and the client can then act on it with the results of that approval*.

**In our printing example**, *the photo-printing service can ask the user, “Do you have any of your photos stored on this storage site? If so, we can totally print that.” The user is then sent to the photo-storage service, which asks, “This printing service is asking to get some of your photos; do you want that to happen?” The user can then decide whether they want that to happen, deciding whether to delegate access to the printing service*.

The distinction between a delegation and an authorization protocol is important here because **the authorizations being carried by the OAuth token are [opaque](https://dictionary.cambridge.org/us/dictionary/english/opaque) to most of the system**. *Only the protected resource needs to know the authorization, and as long as it’s able to find out from the token and its presentation context (either by looking at the token directly or by using a service of some type to obtain this information), it can serve the API as required*.

---

### User-driven security and user choice

**Since the OAuth delegation process involves the *resource owner*, it presents a possibility not found in many other security models**: **:key:important security decisions can be driven by end user choice:key:**. Traditionally, security decisions have been the [purview](https://dictionary.cambridge.org/us/dictionary/english/purview) of centralized authorities. These authorities determine who can use a service, with which client software, and for what purpose. OAuth allows these authorities to push some of that decision-making power into the hands of the users who will ultimately be using the software.

**OAuth systems often follow the principle of TOFU: *[Trust On First Use](https://en.wikipedia.org/wiki/Trust_on_first_use)***. In a TOFU model, the first time a security decision needs to be made at runtime, and there is no existing context or configuration under which the decision can be made, the user is prompted. This can be as simple as “Connect a new application?” although many implementations allow for greater control during this step. Whatever the user experience here, the user with appropriate authority is allowed to make a security decision. The system offers to remember this decision for later use. **In other words, the first time an authorization context is met, the system can be directed to trust the user’s decision for later processing: Trust On First Use**.

**This approach also presents the user’s decision in terms of functionality, *not* security**: **“Do you want this client to do what it’s asking to do?” This is an important distinction from more traditional security models wherein decision makers are asked ahead of time to [demarcate](https://dictionary.cambridge.org/us/dictionary/english/demarcate) what isn’t permissible**. Such security decisions are often [overwhelming](https://dictionary.cambridge.org/us/dictionary/english/overwhelming) for the average user, and in any event the user cares more about what they’re trying to accomplish instead of what they’re trying to prevent.

**Now this isn’t to say that the TOFU method must be used for all transactions or decisions. In practice, a three-layer listing mechanism offers powerful flexibility for security architects (figure 1.9:framed_picture:)**.

