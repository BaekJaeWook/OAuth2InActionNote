OAuth is used for many different kinds of APIs and applications, connecting the online world in ways never before possible. **Even though it’s approaching ubiquity, there are many things that OAuth is not, and it’s important to understand these boundaries when understanding the protocol itself**.

Since OAuth is defined as a framework, there has historically been some confusion regarding what “counts” as OAuth and what does not. For the purposes of this discussion, and truly for the purposes of this book, we’re taking OAuth to mean the protocol defined by the [core OAuth specification](https://tools.ietf.org/html/rfc6749), which details several ways of getting an access token. We’re also including the use of bearer tokens as defined in the [attendant specification](https://tools.ietf.org/html/rfc6750), which dictates how to use this particular style of token. **These two actions—*:key:how to get a token and how to use a token:key:*—are the fundamental parts of OAuth**. As we’ll see in this section, there are a number of other technologies in the wider OAuth ecosystem that work together with the core of OAuth to provide greater functionality than what is available from OAuth itself. We [contend](https://dictionary.cambridge.org/us/dictionary/english/contend) that this ecosystem is evidence of a healthy protocol and shouldn’t be [conflated](https://dictionary.cambridge.org/us/dictionary/english/conflate) with the protocol itself.

***OAuth isn’t defined outside of the HTTP protocol***. **Since OAuth 2.0 with bearer tokens provides no message signatures, it is not meant to be used outside of HTTPS (HTTP over TLS)**. Sensitive secrets and information are passed over the wire, and OAuth requires a transport layer mechanism such as TLS to protect these secrets. A standard exists for presenting OAuth tokens over [Simple Authentication and Security Layer (SASL)–protected protocols](https://tools.ietf.org/html/rfc7628), there are new efforts to define OAuth over [Constrained Application Protocol (CoAP)](https://tools.ietf.org/html/draft-ietf-ace-oauth-authz), and future efforts could make parts of the OAuth process usable over non-TLS links (such as some discussed in chapter 15). But even in these cases, there needs to be a clear mapping from the HTTPS transactions into other protocols and systems.

***OAuth isn’t an authentication protocol*, even though it can be used to build one**. As we’ll cover in greater depth in chapter 13, **an OAuth transaction on its own tells you nothing about who the user is, or even if they’re there**. *Think of our photo-printing example*: the photo printer doesn’t need to know who the user is, only that somebody said it was OK to download some photos. **OAuth is, in essence, an [ingredient](https://dictionary.cambridge.org/us/dictionary/english/ingredient) that can be used in a larger [recipe](https://dictionary.cambridge.org/us/dictionary/english/recipe) to provide other capabilities**. **Additionally, *OAuth uses authentication in several places*, particularly authentication of the resource owner and client software to the authorization server**. **This embedded authentication does not itself make OAuth an authentication protocol**.

***OAuth doesn’t define a mechanism for user-to-user delegation*, even though it is fundamentally about delegation of a user to a piece of software**. OAuth assumes that the resource owner is the one that’s controlling the client. **In order for the resource owner to authorize a different user, more than OAuth is needed**. This kind of delegation is not an uncommon use case, and the User Managed Access protocol (discussed in chapter 14) uses OAuth to create a system capable of user-to-user delegation.

***OAuth doesn’t define authorization-processing mechanisms***. *OAuth provides a means to convey the fact that an authorization delegation has taken place, but it doesn’t define the contents of that authorization. Instead, it is up to the service API definition to use OAuth’s components, such as scopes and tokens, to define what actions a given token is applicable to*.

***OAuth doesn’t define a token format***. In fact, the OAuth protocol explicitly states that **the content of the token is completely opaque to the client application**. This is a [departure](https://dictionary.cambridge.org/us/dictionary/english/departure) from previous security protocols such as WS-*, Security Assertion Markup Language (SAML), or Kerberos, in which the client application needed to be able to parse and process the token. **However, the token still needs to be understood by the authorization server that issues it and the protected resource that accepts it**. Desire for [interoperability](https://dictionary.cambridge.org/us/dictionary/english/interoperability) at this level has led to the development of the JSON Web Token (JWT) format and the Token [Introspection](https://dictionary.cambridge.org/us/dictionary/english/introspection) protocol, discussed in chapter 11. The token itself remains opaque to the client, but now other parties can understand its format.

***OAuth 2.0 defines no cryptographic methods***, unlike OAuth 1.0. Instead of defining a new set of cryptographic mechanisms specific to OAuth, the OAuth 2.0 protocol is built to allow the reuse of more general-purpose cryptographic mechanisms that can be used outside of OAuth. This [deliberate](https://dictionary.cambridge.org/us/dictionary/english/deliberate) [omission](https://dictionary.cambridge.org/us/dictionary/english/omission) has helped lead to the development of the JSON Object Signing and Encryption (JOSE) suite of specifications, which provides general-purpose cryptographic mechanisms that can be used alongside and even outside OAuth. We’ll see more of the JOSE specifications in chapter 11 and apply them to a message-level cryptographic protocol using OAuth Proof of Possession (PoP) tokens in chapter 15.

***OAuth 2.0 is also not a single protocol***. As discussed previously, the specification is split into multiple definitions and flows, each of which has its own set of use cases. The core OAuth 2.0 specification has somewhat accurately been described as a security protocol generator, because it can be used to design the security architecture for many different use cases. As discussed in the previous section, these systems aren’t necessarily compatible with each other.

**Instead of attempting to be a monolithic protocol that solves all aspects of a security system, OAuth focuses on one thing and leaves room for other components to play their parts where it makes more sense**. Although there are many things that OAuth is not, OAuth does provide a solid basis that can be built on by other focused tools to create more comprehensive security architecture designs.