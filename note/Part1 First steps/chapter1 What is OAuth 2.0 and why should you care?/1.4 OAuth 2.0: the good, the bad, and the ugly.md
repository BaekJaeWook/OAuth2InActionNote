**OAuth 2.0 is very good at capturing a user delegation decision and expressing that across the network**. It allows for multiple different parties to be involved in the security decision process, most notably the end user at runtime. It’s a protocol made up of many different moving parts, but in many ways it’s far simpler and more secure than the alternatives.

**One key assumption in the design of OAuth 2.0 was that there would always be several [orders of magnitude](https://dictionary.cambridge.org/us/dictionary/english/order-of-magnitude) more clients in the wild than there would be authorization servers or protected resource servers (figure 1.10:framed_picture:)**. This makes sense, as a single authorization server can easily protect multiple resource servers, and there are likely to be many different kinds of clients wanting to consume any given API. **An authorization server can even have several different classes of clients that are trusted at different levels, but we’ll cover that in more depth in chapter 12**. **As a consequence of this architectural decision, wherever possible, complexity is shifted away from clients and onto servers**. This is good for client developers, as the client becomes the simplest piece of software in the system. Client developers no longer have to deal with signature normalizations or parsing complicated security policy documents, as they would have in previous security protocols, and they no longer have to worry about handling sensitive user credentials. OAuth tokens provide a mechanism that’s only slightly more complex than passwords but significantly more secure when used properly.

**The [flip side](https://dictionary.cambridge.org/us/dictionary/english/flip-side) is that authorization servers and protected resources are now responsible for more of the complexity and security**. A client needs to manage securing only its own client credentials and the user’s tokens, and the breach of a single client would be bad but limited in its damage to the users of that client. Breaching the client also doesn’t expose the resource owner’s credentials, since the client never sees them in the first place. An authorization server, on the other hand, needs to manage and secure the credentials and tokens for all clients and all users on a system. Although this does make it more of a target for attack, it’s significantly easier to make a single authorization server highly secure than it is to make a thousand clients written by independent developers just as secure.

**The extensibility and modularity of OAuth 2.0 form one of its greatest assets, since it allows the protocol to be used in a wide variety of environments**. **However, this same flexibility leads to basic incompatibility problems between implementations**. OAuth leaves many pieces optional, which can confuse developers who are trying to implement it between two systems.

**Even worse, some of the available options in OAuth can be taken in the wrong context or not enforced properly, leading to insecure implementations**. These kinds of vulnerabilities are discussed at length in the [OAuth Threat Model Document](https://tools.ietf.org/html/rfc6819) and the vulnerabilities section of this book (chapters 7, 8, 9, and 10). **Suffice it to say, the fact that a system implements OAuth, and even implements it correctly according to the spec, doesn’t mean that this system is secure in practice**.

**Ultimately, OAuth 2.0 is a good protocol, but it’s far from perfect**. We will see its replacement at some point in the future, as with all things in technology, but no real [contender](https://dictionary.cambridge.org/us/dictionary/english/contender) has yet [emerged](https://dictionary.cambridge.org/us/dictionary/english/emerge) as of the writing of this book. It’s just as likely that OAuth 2.0’s replacement will end up being a profile or extension of OAuth 2.0 itself.