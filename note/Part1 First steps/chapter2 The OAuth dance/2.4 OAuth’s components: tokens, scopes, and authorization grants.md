**In addition to these actors, the OAuth ecosystem depends on several other mechanisms, both conceptual and physical**. **These are the [bits](https://dictionary.cambridge.org/us/dictionary/english/bit) that connect the actors in the previous section in a larger protocol**.

### Access tokens
**An *OAuth access token*, sometimes known as just a token in casual reference, is :key:an [artifact](https://dictionary.cambridge.org/us/dictionary/english/artifact) issued by the authorization server to a client that indicates the rights that the client has been delegated:key:**. OAuth does not define a format or content for the token itself, but it always represents the combination of the client’s requested access, the resource owner that authorized the client, and the rights [conferred](https://dictionary.cambridge.org/us/dictionary/english/confer) during that authorization (usually including some indication of the protected resource).

**OAuth tokens are :key:*opaque*:key: to the client, which means that the client has no need (and often no ability) to look at the token itself**. The client’s job is to carry the token, requesting it from the authorization server and presenting it to the protected resource. **The token isn’t opaque to everyone in the system: the authorization server’s job is to issue the token, and the protected resource’s job is to validate the token**. **As such, they both need to be able to understand the token itself and what it stands for**. However, the client is completely [oblivious](https://dictionary.cambridge.org/us/dictionary/english/oblivious) to all of this. This approach allows the client to be much simpler than it would otherwise need to be, as well as giving the authorization server and protected resource incredible flexibility in how these tokens are deployed.

---

### Scopes
**:key:An OAuth scope is a representation of a set of rights at a protected resource:key:**. Scopes are represented by strings in the OAuth protocol, and they can be combined into a set by using a space-separated list. As such, the scope value can’t contain the space character. The format and structure of the scope value are otherwise undefined by OAuth.

**Scopes are an important [mechanism](https://dictionary.cambridge.org/us/dictionary/english/mechanism) for limiting the access granted to a client**. **Scopes are defined by the protected resource, based on the API that it’s offering**. Clients can request certain scopes, and the authorization server can allow the resource owner to grant or deny particular scopes to a given client during its request. Scopes are generally additive in nature.

**Let’s return to our cloud-printing example**. *The photo-storage service’s API defines several different scopes for accessing the photos: read-photo, read-metadata, update-photo, update-metadata, create, and delete*. The photo-printing service needs to be able only to read the photos in order to do its job, and so it asks for the read-photo scope. Once it has an access token with this scope, the printer is able to read photos and print images out as requested. If the user decides to use an advanced function that prints a series of photographs into a book based on their date, the printing service will need the additional read-metadata scope. Since this is an additional access, the printing service needs to ask the user to authorize them for this additional scope using the regular OAuth process. Once the printing service has an access token with both scopes, it can perform actions that require either of them, or both of them together, using the same access token.

---

### Refresh tokens
*An OAuth refresh token is **similar** in concept to the access token, in that it’s issued to the client by the authorization server and the client doesn’t know or care what’s inside the token*. **What’s different, though, is that the token is never sent to the protected resource. Instead, the client uses the refresh token to request new access tokens without involving the resource owner (figure 2.10:framed_picture:)**​.

**Why would a client need to [bother](https://dictionary.cambridge.org/us/dictionary/english/bother) with a refresh token?** **In OAuth, an access token could stop working for a client at any point**. The user could have revoked the token, the token could have expired, or some other system trigger made the token invalid. The client will usually find out about the token being invalid by using it and receiving an error response. *Of course, the client could have the resource owner authorize it again, but what if the resource owner’s no longer there?*

*In OAuth 1.0, the client had no [recourse](https://dictionary.cambridge.org/us/dictionary/english/recourse) but to wait for the resource owner’s return*. *To avoid this, tokens in OAuth 1.0 tended to live forever until explicitly revoked*. This is a bit problematic as it increases the attack surface for a stolen token: the attacker can keep using the stolen token forever. *In OAuth 2.0, access tokens were given the option to expire automatically, but we still need a way to access resources when the user was no longer there*. The refresh token now takes the place of the long-lived token, but instead of it being used to obtain resources, it’s used only to get new access tokens that, in turn, can get the resources. This limits the exposure of the refresh token and the access token in separate but [complementary](https://dictionary.cambridge.org/us/dictionary/english/complementary) ways.

**Refresh tokens also give the client the ability to down-scope its access**. If a client is granted scopes A, B, and C, but it knows that it needs only scope A to make a particular call, it can use the refresh token to request an access token for only scope A. This lets a smart client follow the security principle of least privilege without [burdening](https://dictionary.cambridge.org/us/dictionary/english/burden) less-smart clients with trying to figure out what privileges an API needs. Years of deployment experience have shown that OAuth clients tend to be anything but smart, but it’s still good to have the advanced capability there for those that want to exercise it.

**What then if the refresh token itself doesn’t work?** **The client can always bother the resource owner again, when they’re available**. In other words, the fallback state for an OAuth client is to do OAuth again.

---

### Authorization grants
**An authorization grant is the means by which an OAuth client is given access to a protected resource using the OAuth protocol, and if successful it ultimately results in the client getting a token**. This is likely **one of the most confusing terms** in OAuth 2.0, **because the term is used to define both the specific mechanism by which the user delegates authority as well as the act of delegation itself**. This is further confused by the authorization code grant type, which we laid out in detail previously, as developers will sometimes look at the authorization code that is passed back to the client and mistakenly assume that this artifact—and this artifact alone—is the authorization grant. Although it’s true that the authorization code represents a user’s authorization decision, it is not itself an authorization grant. **Instead, the entire OAuth process is the authorization grant: the client sending the user to the authorization endpoint, then receiving the code, then finally trading the code for the token**.

**:key:In other words, the authorization grant is the method for getting a token:key:**. In this book, as in the OAuth community as a whole, we’ll occasionally refer to this as a flow of the OAuth protocol. *Several different kinds of authorization grants exist in OAuth, each with its own characteristics*. We’ll be covering these in detail in chapter 6, but most of our examples and exercises, such as those in the previous section, use  the authorization code authorization grant type.