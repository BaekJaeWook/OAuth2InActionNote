*As seen in the previous chapters*, **both the authorization code and the implicit grant types mention a recommended *state parameter***. This parameter is, according to the [OAuth core specification](https://tools.ietf.org/html/rfc6749):

> **An opaque value used by the client to maintain state between the request and callback**. The authorization server includes this value when redirecting the user-agent back to the client. **The parameter SHOULD be used for preventing [cross-site request forgery](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)) ([CSRF](https://www.youtube.com/watch?v=vRBihr41JTo)).**

**What is cross-site request forgery (CSRF) then, and why should we pay attention to it?** To start with the second part of the question, CSRF is one of the most common attacks on the internet, and it’s also listed in the OWASP Top Ten, a list of the current 10 most dangerous web application security flaws and effective methods for dealing with them. One of the main reasons for its popularity is the fact that this threat isn’t well understood by the average developer, thus providing an easier target for the attacker. 

**CSRF occurs when a malicious application causes the user’s browser to perform an unwanted action through a request to a web site where the user is currently authenticated**. *How is that possible? The main thing to keep in mind is that browsers make requests (with cookies) to any origin, allowing specific actions to be performed when requested. If a user is logged in to one site that offers the capability to execute some sort of task and an attacker tricks the user’s browser into making a request to one of these task URIs, then the task is performed as the logged-in user*. Typically, an attacker will embed malicious HTML or JavaScript code into an email or website to request a specific task URI that executes without the user’s knowledge (see figure 7.1:framed_picture:).

**The most common and effective [mitigation](https://dictionary.cambridge.org/us/dictionary/english/mitigation) is to add an :key:unpredictable element:key: in each HTTP request, which is the [countermeasure](https://dictionary.cambridge.org/us/dictionary/english/countermeasure) taken by the OAuth specification**. Let’s see why the use of the state parameter is highly encouraged to avoid CSRF and how to produce a proper state parameter to be safely used. We will demonstrate this with :key:[an example attack](http://homakov.blogspot.com/2012/07/saferweb-most-common-oauth2.html):key:. Let’s assume there is an OAuth client that supports the authorization code grant type. When the OAuth client receives a code parameter on its OAuth callback endpoint, it then will trade the received code for an access token. Eventually, the access token is passed to the resource server when the client calls an API on behalf of the resource owner. **To perform the attack, the attacker can simply start an OAuth flow and get an authorization code from the target authorization server, stopping his “OAuth dance” here. The attacker causes the victim’s client to “consume” the attacker’s authorization code**. The latter is achieved by creating a malicious page in his website, something like:

```html
<img src="https://ouauthclient.com/callback?code=ATTACKER_AUTHORIZATION_CODE">
```

and convince the victim to visit it (figure 7.2:framed_picture:).

**:key:This would have the [net effect](https://www.ldoceonline.com/dictionary/net-result-effect) of the resource owner having his client application connected with the attacker’s authorization context. This has disastrous consequences when the OAuth protocol is used for authentication, which is further discussed in chapter 13:key:**.

**The mitigation for an OAuth client is to generate an unguessable state parameter and pass it along to the first call to the authorization server**. *The authorization server is required by the specification to return this value as-is as one of the parameters to the redirect URI. Then when the redirect URI is called, the client checks the value of the state parameter. If it is absent or if it doesn’t match the value originally passed, the client can terminate the flow with an error*. This prevents an attacker from using their own authorization code and injecting it into an unsuspecting victim’s client.

